{
  "language": "Solidity",
  "sources": {
    "contracts/MiMCSponge.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\ncontract Hasher {\r\n    uint256 p = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    uint256[20] c = [\r\n        0,\r\n        25823191961023811529686723375255045606187170120624741056268890390838310270028,\r\n        71153255768872006974285801937521995907343848376936063113800887806988124358800,\r\n        51253176922899201987938365653129780755804051536550826601168630951148399005246,\r\n        66651710483985382365580181188706173532487386392003341306307921015066514594406,\r\n        45887003413921204775397977044284378920236104620216194900669591190628189327887,\r\n        14399999722617037892747232478295923748665564430258345135947757381904956977453,\r\n        29376176727758177809204424209125257629638239807319618360680345079470240949145,\r\n        13768859312518298840937540532277016512087005174650120937309279832230513110846,\r\n        54749662990362840569021981534456448557155682756506853240029023635346061661615,\r\n        25161436470718351277017231215227846535148280460947816286575563945185127975034,\r\n        90370030464179443930112165274275271350651484239155016554738639197417116558730,\r\n        92014788260850167582827910417652439562305280453223492851660096740204889381255,\r\n        40376490640073034398204558905403523738912091909516510156577526370637723469243,\r\n        903792244391531377123276432892896247924738784402045372115602887103675299839,\r\n        112203415202699791888928570309186854585561656615192232544262649073999791317171,\r\n        114801681136748880679062548782792743842998635558909635247841799223004802934045,\r\n        111440818948676816539978930514468038603327388809824089593328295503672011604028,\r\n        64965960071752809090438003157362764845283225351402746675238539375404528707397,\r\n        98428510787134995495896453413714864789970336245473413374424598985988309743097\r\n    ];\r\n\r\n    function MiMC5Feistel(uint256 _iL, uint256 _iR, uint256 _k) internal view returns(uint256 oL, uint256 oR) {\r\n        uint8 nRounds = 20;\r\n\r\n        uint256 lastL = _iL;\r\n        uint256 lastR = _iR;\r\n\r\n        uint256 mask;\r\n        uint256 mask2;\r\n        uint256 mask4;\r\n        uint256 temp;\r\n\r\n        for(uint8 i = 0; i < nRounds; i++){\r\n            mask = addmod(lastR, _k, p);\r\n            mask = addmod(mask, c[i], p);\r\n            mask2 = mulmod(mask, mask, p);\r\n            mask4 = mulmod(mask2, mask2, p);\r\n            mask = mulmod(mask4, mask, p);\r\n\r\n            temp = lastR;\r\n            lastR = addmod(lastL, mask, p);\r\n            lastL = temp;\r\n        }\r\n\r\n        return (lastL, lastR);\r\n    }\r\n    function MiMC5Sponge(uint256[2] memory _ins, uint256 _k) external view returns(uint256 h) {\r\n        uint256 lastR = 0;\r\n        uint256 lastC = 0;\r\n\r\n        for(uint8 i = 0; i < _ins.length; i++){\r\n            lastR = addmod(lastR, _ins[i], p);\r\n            (lastR, lastC) = MiMC5Feistel(lastR, lastC, _k);\r\n        }\r\n\r\n        h = lastR;\r\n    }\r\n}"
    },
    "contracts/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}"
    },
    "contracts/Tornado.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity 0.8.17;\r\n// to prevent Reentrancy Attacks \r\nimport \"./ReentrancyGuard.sol\";\r\n// this is just a hashing procedure does several rounds of hashing based on an equation and then makes it computationally impossible  to reverse [the logarithmic problem ]\r\nimport \"./MiMCSponge.sol\";\r\n\r\ncontract Tornado is ReentrancyGuard {\r\n\r\n    address verifier ;\r\n    Hasher hasher;\r\n\r\n    uint8 public treeLevel = 10;\r\n    uint256 public denomination= 0.001 ether;\r\n\r\n\r\n    uint256 public nextLeafIdx = 0;\r\n    //tracking the root of the merkle tree that tracks deposits commentment hash\r\n    mapping(uint256 => bool) public roots;\r\n\r\n    // so what happens is that there is an array that when the deposit done stores the commitment hash and the  travereses with hashing till it gets to the root . so the lastlevel hash is to check a sister node if it hash a hash or not so that the parent node can produce a new hash either based on both the sister node and the incoming deposit commitment hash or the incoming commitment hash alone\r\n    mapping(uint8 => uint256 )lastLevelHash;\r\n\r\n\r\n\r\n// so what happens is that the user provides two 32 byte random string ..   [secret and the nullifer].. these two are then used with the circuit that uses the Pedersen hashing mechanism to output a commitment hash and a nullifier hash ... this mapping is to track that nullifierhash . this hash is also important when we are withdrawing because we can use it to know if the withdrawal has been done or not \r\n    mapping (uint256 => bool) public nulliferHashes;\r\n\r\n// track which commitment hashes come to the merkle tree .. make sure there are not duplicate hashes to prevent hash collision \r\n    mapping(uint256 => bool) public commitments;\r\n\r\n\r\n// default values for each level of the Merkle tree.. we generate 32 bytes ... uint256   remember to build a merkle tree you have to start with a non empty array with the power of 2 \r\nuint256[10] levelDefaults = [\r\n        23183772226880328093887215408966704399401918833188238128725944610428185466379,\r\n        24000819369602093814416139508614852491908395579435466932859056804037806454973,\r\n        90767735163385213280029221395007952082767922246267858237072012090673396196740,\r\n        36838446922933702266161394000006956756061899673576454513992013853093276527813,\r\n        68942419351509126448570740374747181965696714458775214939345221885282113404505,\r\n        50082386515045053504076326033442809551011315580267173564563197889162423619623,\r\n        73182421758286469310850848737411980736456210038565066977682644585724928397862,\r\n        60176431197461170637692882955627917456800648458772472331451918908568455016445,\r\n        105740430515862457360623134126179561153993738774115400861400649215360807197726,\r\n        76840483767501885884368002925517179365815019383466879774586151314479309584255\r\n    ];\r\n\r\n\r\n    event Deposit(uint256 root, uint256[10] hashingPairings, uint8[10] pairDirection);\r\n\r\n    event Withdrawal(address to , uint256 nullifierhash);\r\n\r\n\r\n\r\n// so before we deploy this contract we deploy the MIMCSponge Contract to get the access to the functions that would enable us to hash our secret and nullifier.. \r\n//another things is that we need the verifier contract to verfy the commitment when withdrawing that would be produced from the Groth 16.. but the smart contract version from Groth 16 is old so we cannot instantiate it like the Hasher .. for the Hasher contract we built it and set its version to be the same of this one .. so we just use the address*****\r\n\r\n// so we are using the deposit circom file to create the witness expresssion \r\n\r\n//we create a verfier smart contract from the withdrwal circom file to prove we are the right people to withdraw \r\n\r\n    constructor(address _hasher){\r\n        hasher = Hasher(_hasher);\r\n        //verifier = verifierAddress;\r\n\r\n    \r\n\r\n    }\r\n\r\n\r\n    function deposit(uint256 _commitment) external payable nonReentrant{\r\n        // make sure that the amount sent is allowed \r\n        require(msg.value == denomination, \"Incorrect denomination of ETH\");\r\n        //make sure the incoming commitmenthash is not  a duplicate to prevent hash collision\r\n        require(!commitments[_commitment], \"Duplicate action\");\r\n\r\n        // we have a set number of txn allowed and this is based on  the level of our merkle tree if the level is 10 the number of nodes would be 2^10\r\n\r\n            //                    Level 9:  #\r\n            //                   /        \\\r\n            //         Level 8:  *          *\r\n            //                   / \\        / \\\r\n            //         Level 7:  +   -      =\r\n            //                 / \\ / \\    / \\\r\n            //       Level 6:  #   *  /    *\r\n            //                   / \\ / \\  / \\\r\n            //         Level 5:  *   ~  #    +\r\n            //                 / \\ / \\ / \\  / \\\r\n            //       Level 4:  ^   v  v    ^   v\r\n            //               / \\ / \\ / \\  / \\ / \\\r\n            //     Level 3:  ~   =  -    +   *   #\r\n            //               / \\ / \\ / \\  / \\ / \\\r\n            //     Level 2:  v   ^  ^    ~   =   +\r\n            //             / \\ / \\ / \\  / \\ / \\ / \\\r\n            //   Level 1:  *   ~  #    -   +\r\n            //             / \\ / \\ / \\  / \\ / \\ / \\\r\n            // Level 0:   ^   ~  =    +   -   *   *\r\n            //            / \\ / \\ / \\  / \\ / \\ / \\ / \\\r\n\r\n            // each level has a commitment hash when the deposit is made so if the all the sister nodes of each level is full then we cannot deposit \r\n            require(nextLeafIdx < 2 ** treeLevel,\"Cannot deposit merkle tree is full\");\r\n\r\n            uint256 newRoot;\r\n            uint256[10] memory hashPairings;\r\n            uint256[10] memory hashDirection;\r\n\r\n           uint256 currentIndex = nextLeafIdx;\r\n           uint256 left ;\r\n           uint256 right;\r\n\r\n           uint256 currentHash = _commitment;\r\n           uint256[2] memory _ins; // current hash  + the proof  in an array so we pass it to the MiMc function to hash it \r\n\r\n\r\n            for(uint i =0; i< treeLevel; i++){\r\n                if(currentIndex % 2 == 0){\r\n                    // this that our index is an even number and so its on the left .. so we take the right value and update the hashPairing with that to be read to hash it with sponge\r\n                    left = currentHash;\r\n                    right= levelDefaults[i];\r\n                    // even numbers is 0  \r\n                    hashDirection[i] = 0;\r\n                    hashPairings[i] = levelDefaults[i];\r\n\r\n\r\n\r\n                }else{\r\n                    right = currentHash;\r\n                    left = levelDefaults[i];\r\n                    // since the index is an odd number its on the right \r\n                    hashDirection[i] = 1;\r\n                    hashPairings[i] = levelDefaults[i];\r\n                    \r\n                }\r\n                 _ins[0] = left;\r\n                _ins[1] = right;\r\n           (uint256 h) = hasher.MiMC5Sponge{gas:150000}(_ins,  _commitment);\r\n           \r\n                currentIndex= currentIndex /2;\r\n                   currentHash = h;\r\n                \r\n    \r\n            }\r\n\r\n            newRoot = currentHash;\r\n            roots[newRoot] = true;\r\n            nextLeafIdx+=1;\r\n\r\n            commitments[_commitment] = true;\r\n\r\n        \r\n\r\n\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}