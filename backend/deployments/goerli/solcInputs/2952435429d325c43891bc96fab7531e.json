{
  "language": "Solidity",
  "sources": {
    "contracts/ifaces/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\ninterface IVerifier {\r\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[3] calldata _pubSignals) external view returns (bool);\r\n}"
    },
    "contracts/MiMCSponge.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\ncontract Hasher {\r\n    uint256 p = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    uint256[20] c = [\r\n        0,\r\n        25823191961023811529686723375255045606187170120624741056268890390838310270028,\r\n        71153255768872006974285801937521995907343848376936063113800887806988124358800,\r\n        51253176922899201987938365653129780755804051536550826601168630951148399005246,\r\n        66651710483985382365580181188706173532487386392003341306307921015066514594406,\r\n        45887003413921204775397977044284378920236104620216194900669591190628189327887,\r\n        14399999722617037892747232478295923748665564430258345135947757381904956977453,\r\n        29376176727758177809204424209125257629638239807319618360680345079470240949145,\r\n        13768859312518298840937540532277016512087005174650120937309279832230513110846,\r\n        54749662990362840569021981534456448557155682756506853240029023635346061661615,\r\n        25161436470718351277017231215227846535148280460947816286575563945185127975034,\r\n        90370030464179443930112165274275271350651484239155016554738639197417116558730,\r\n        92014788260850167582827910417652439562305280453223492851660096740204889381255,\r\n        40376490640073034398204558905403523738912091909516510156577526370637723469243,\r\n        903792244391531377123276432892896247924738784402045372115602887103675299839,\r\n        112203415202699791888928570309186854585561656615192232544262649073999791317171,\r\n        114801681136748880679062548782792743842998635558909635247841799223004802934045,\r\n        111440818948676816539978930514468038603327388809824089593328295503672011604028,\r\n        64965960071752809090438003157362764845283225351402746675238539375404528707397,\r\n        98428510787134995495896453413714864789970336245473413374424598985988309743097\r\n    ];\r\n\r\n    function MiMC5Feistel(uint256 _iL, uint256 _iR, uint256 _k) internal view returns(uint256 oL, uint256 oR) {\r\n        uint8 nRounds = 20;\r\n\r\n        uint256 lastL = _iL;\r\n        uint256 lastR = _iR;\r\n\r\n        uint256 mask;\r\n        uint256 mask2;\r\n        uint256 mask4;\r\n        uint256 temp;\r\n\r\n        for(uint8 i = 0; i < nRounds; i++){\r\n            mask = addmod(lastR, _k, p);\r\n            mask = addmod(mask, c[i], p);\r\n            mask2 = mulmod(mask, mask, p);\r\n            mask4 = mulmod(mask2, mask2, p);\r\n            mask = mulmod(mask4, mask, p);\r\n\r\n            temp = lastR;\r\n            lastR = addmod(lastL, mask, p);\r\n            lastL = temp;\r\n        }\r\n\r\n        return (lastL, lastR);\r\n    }\r\n    function MiMC5Sponge(uint256[2] memory _ins, uint256 _k) external view returns(uint256 h) {\r\n        uint256 lastR = 0;\r\n        uint256 lastC = 0;\r\n\r\n        for(uint8 i = 0; i < _ins.length; i++){\r\n            lastR = addmod(lastR, _ins[i], p);\r\n            (lastR, lastC) = MiMC5Feistel(lastR, lastC, _k);\r\n        }\r\n\r\n        h = lastR;\r\n    }\r\n}"
    },
    "contracts/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}"
    },
    "contracts/Tornado.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity 0.8.17;\r\n// to prevent Reentrancy Attacks \r\nimport \"./ReentrancyGuard.sol\";\r\n// this is just a hashing procedure does several rounds of hashing based on an equation and then makes it computationally impossible  to reverse [the logarithmic problem ]\r\nimport \"./MiMCSponge.sol\";\r\nimport \"./ifaces/IVerifier.sol\";\r\n\r\ncontract Tornado is ReentrancyGuard {\r\n\r\n    address verifier ;\r\n    Hasher hasher;\r\n\r\n    uint8 public treeLevel = 10;\r\n    uint256 public denomination= 0.001 ether;\r\n\r\n\r\n    uint256 public nextLeafIdx = 0;\r\n    //tracking the root of the merkle tree that tracks deposits commentment hash\r\n    mapping(uint256 => bool) public roots;\r\n\r\n    // so what happens is that there is an array that when the deposit done stores the commitment hash and the  travereses with hashing till it gets to the root . so the lastlevel hash is to check a sister node if it hash a hash or not so that the parent node can produce a new hash either based on both the sister node and the incoming deposit commitment hash or the incoming commitment hash alone\r\n    mapping(uint8 => uint256 )lastLevelHash;\r\n\r\n\r\n\r\n// so what happens is that the user provides two 32 byte random string ..   [secret and the nullifer].. these two are then used with the circuit that uses the Pedersen hashing mechanism to output a commitment hash and a nullifier hash ... this mapping is to track that nullifierhash . this hash is also important when we are withdrawing because we can use it to know if the withdrawal has been done or not \r\n    mapping (uint256 => bool) public nulliferHashes;\r\n\r\n// track which commitment hashes come to the merkle tree .. make sure there are not duplicate hashes to prevent hash collision \r\n    mapping(uint256 => bool) public commitments;\r\n\r\n\r\n// default values for each level of the Merkle tree.. we generate 32 bytes ... uint256   remember to build a merkle tree you have to start with a non empty array with the power of 2 \r\nuint256[10] levelDefaults = [\r\n        23183772226880328093887215408966704399401918833188238128725944610428185466379,\r\n        24000819369602093814416139508614852491908395579435466932859056804037806454973,\r\n        90767735163385213280029221395007952082767922246267858237072012090673396196740,\r\n        36838446922933702266161394000006956756061899673576454513992013853093276527813,\r\n        68942419351509126448570740374747181965696714458775214939345221885282113404505,\r\n        50082386515045053504076326033442809551011315580267173564563197889162423619623,\r\n        73182421758286469310850848737411980736456210038565066977682644585724928397862,\r\n        60176431197461170637692882955627917456800648458772472331451918908568455016445,\r\n        105740430515862457360623134126179561153993738774115400861400649215360807197726,\r\n        76840483767501885884368002925517179365815019383466879774586151314479309584255\r\n    ];\r\n\r\n\r\n    event Deposit(uint256 root, uint256[10] hashingPairings, uint8[10] pairDirection);\r\n\r\n    event Withdrawal(address to , uint256 nullifierhash);\r\n\r\n\r\n\r\n// so before we deploy this contract we deploy the MIMCSponge Contract to get the access to the functions that would enable us to hash our secret and nullifier.. \r\n//another things is that we need the verifier contract to verfy the commitment when withdrawing that would be produced from the Groth 16.. but the smart contract version from Groth 16 is old so we cannot instantiate it like the Hasher .. for the Hasher contract we built it and set its version to be the same of this one .. so we just use the address*****\r\n\r\n// so we are using the deposit circom file to create the witness expresssion \r\n\r\n//we create a verfier smart contract from the withdrwal circom file to prove we are the right people to withdraw \r\n\r\n    constructor(address _hasher, address verifierAddress){\r\n        hasher = Hasher(_hasher);\r\n        verifier = verifierAddress;\r\n\r\n    \r\n\r\n    }\r\n\r\n\r\n    function deposit(uint256 _commitment) external payable nonReentrant{\r\n        // make sure that the amount sent is allowed \r\n        require(msg.value == denomination, \"Incorrect denomination of ETH\");\r\n        //make sure the incoming commitmenthash is not  a duplicate to prevent hash collision\r\n        require(!commitments[_commitment], \"Duplicate action\");\r\n\r\n        // we have a set number of txn allowed and this is based on  the level of our merkle tree if the level is 10 the number of nodes would be 2^10\r\n\r\n            //                    Level 9:  #\r\n            //                   /        \\\r\n            //         Level 8:  *          *\r\n            //                   / \\        / \\\r\n            //         Level 7:  +   -      =\r\n            //                 / \\ / \\    / \\\r\n            //       Level 6:  #   *  /    *\r\n            //                   / \\ / \\  / \\\r\n            //         Level 5:  *   ~  #    +\r\n            //                 / \\ / \\ / \\  / \\\r\n            //       Level 4:  ^   v  v    ^   v\r\n            //               / \\ / \\ / \\  / \\ / \\\r\n            //     Level 3:  ~   =  -    +   *   #\r\n            //               / \\ / \\ / \\  / \\ / \\\r\n            //     Level 2:  v   ^  ^    ~   =   +\r\n            //             / \\ / \\ / \\  / \\ / \\ / \\\r\n            //   Level 1:  *   ~  #    -   +\r\n            //             / \\ / \\ / \\  / \\ / \\ / \\\r\n            // Level 0:   ^   ~  =    +   -   *   *\r\n            //            / \\ / \\ / \\  / \\ / \\ / \\ / \\\r\n\r\n            // each level has a commitment hash when the deposit is made so if the all the sister nodes of each level is full then we cannot deposit \r\n            require(nextLeafIdx < 2 ** treeLevel,\"Cannot deposit merkle tree is full\");\r\n\r\n            uint256 newRoot;\r\n            uint256[10] memory hashPairings;\r\n            uint256[10] memory hashDirection;\r\n\r\n           uint256 currentIndex = nextLeafIdx;\r\n           uint256 left ;\r\n           uint256 right;\r\n\r\n           uint256 currentHash = _commitment;\r\n           uint256[2] memory _ins; // current hash  + the proof  in an array so we pass it to the MiMc function to hash it \r\n\r\n\r\n            for(uint i =0; i< treeLevel; i++){\r\n                if(currentIndex % 2 == 0){\r\n                    // this that our index is an even number and so its on the left .. so we take the right value and update the hashPairing with that to be read to hash it with sponge\r\n                    left = currentHash;\r\n                    right= levelDefaults[i];\r\n                    // even numbers is 0  \r\n                    hashDirection[i] = 0;\r\n                    hashPairings[i] = levelDefaults[i];\r\n\r\n\r\n\r\n                }else{\r\n                    right = currentHash;\r\n                    left = levelDefaults[i];\r\n                    // since the index is an odd number its on the right \r\n                    hashDirection[i] = 1;\r\n                    hashPairings[i] = levelDefaults[i];\r\n                    \r\n                }\r\n                 _ins[0] = left;\r\n                _ins[1] = right;\r\n           (uint256 h) = hasher.MiMC5Sponge{gas:150000}(_ins,  _commitment);\r\n           \r\n                currentIndex= currentIndex /2;\r\n                   currentHash = h;\r\n                \r\n    \r\n            }\r\n\r\n            newRoot = currentHash;\r\n            roots[newRoot] = true;\r\n            nextLeafIdx+=1;\r\n\r\n            commitments[_commitment] = true;\r\n\r\n        \r\n\r\n\r\n    }\r\n\r\n    function withdraw(\r\n        uint256[2] calldata a,\r\n        uint256[2][2] calldata b, \r\n        uint256[2] calldata c,\r\n        uint256[2] calldata input // this is the nullifyhash and the commitment hash\r\n    ) public  nonReentrant{\r\n\r\n        // we make variables for the output variables of our withdraw circuit\r\n        uint256 depositRoot = input[0];\r\n        uint256 nulliferHash = input[1];\r\n        // we dont expose the recipient address in the smart contract \r\n        uint256 _addressofWithdraw = uint256(uint160(msg.sender));\r\n\r\n        require(roots[depositRoot], \"no-root\");\r\n        require(!nulliferHashes[nulliferHash], \"Cannot withdraw twice\");\r\n\r\n        // now lets verify if the information from the circuit is right so we call the Verifier contract\r\n        (bool ok,) = verifier.call(abi.encodeCall(IVerifier.verifyProof, (a, b, c, [depositRoot, nulliferHash, _addressofWithdraw])));\r\n\r\n        require(ok , \"Invalid Proof\");\r\n        nulliferHashes[nulliferHash] = true;\r\n\r\n\r\n       address payable _addrr = payable(msg.sender);\r\n\r\n      (bool success,) = _addrr.call{value: denomination, gas: 5000}(\r\n            \"\");\r\n               require(success , \"Sending error\");\r\n\r\n        \r\n\r\n        emit Withdrawal(_addrr, nulliferHash );\r\n\r\n        \r\n\r\n    }\r\n}"
    },
    "contracts/Verifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Groth16Verifier {\n    // Scalar field size\n    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    // Base field size\n    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // Verification Key data\n    uint256 constant alphax  = 8150020295981585307478283832359552265462176312187988029035358111707501014066;\n    uint256 constant alphay  = 20913390685983058084211285661167099608727577289147061334306441171857393219801;\n    uint256 constant betax1  = 4255579011608506852143301216674072704563873314957311035724929062038257938714;\n    uint256 constant betax2  = 3333870894541509441385744263043375537095839018851420288136644527257115569342;\n    uint256 constant betay1  = 9854949990364624633552078173732885619062707722544683698013946620754474599713;\n    uint256 constant betay2  = 21658814042011536209864553346729587664247524823563007211172040345412604362699;\n    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint256 constant deltax1 = 6093693044723630693277643390933203930568490851611705629465306499952007061362;\n    uint256 constant deltax2 = 10579785711788825321824111291364193530446246352577574881771907795120560596203;\n    uint256 constant deltay1 = 16333859941045372716185668741962019615352617686320457957945051637496153656663;\n    uint256 constant deltay2 = 2109546034550934617148872695344288724538507142792773507685986003241723115387;\n\n    \n    uint256 constant IC0x = 7724212964309540477163401941514573154031463830927843366184044533288788603844;\n    uint256 constant IC0y = 6412848594307764062375758684825313505809061796734389836794088699481325890459;\n    \n    uint256 constant IC1x = 15462214940732558338286676641426651158080329278148349951118126830211434927068;\n    uint256 constant IC1y = 18655714855248180002908196809847248189468567421716405470175082021813686656157;\n    \n    uint256 constant IC2x = 2333036830939263765468110470980760200004800932367594686625464686631419068772;\n    uint256 constant IC2y = 12938407128252587870802156294667698388923690001691964741012397672315887347691;\n    \n    uint256 constant IC3x = 21573957602767367118384452127263400649261371866976903644476232999470016577935;\n    uint256 constant IC3y = 16165704633260570727192152914319203867500798776692546249319122874633333973049;\n    \n \n    // Memory data\n    uint16 constant pVk = 0;\n    uint16 constant pPairing = 128;\n\n    uint16 constant pLastMem = 896;\n\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[3] calldata _pubSignals) public view returns (bool) {\n        assembly {\n            function checkField(v) {\n                if iszero(lt(v, q)) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n            \n            // G1 function to multiply a G1 value(x,y) to value in an address\n            function g1_mulAccC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn, 32), y)\n                mstore(add(mIn, 64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n\n                mstore(add(mIn, 64), mload(pR))\n                mstore(add(mIn, 96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\n                let _pPairing := add(pMem, pPairing)\n                let _pVk := add(pMem, pVk)\n\n                mstore(_pVk, IC0x)\n                mstore(add(_pVk, 32), IC0y)\n\n                // Compute the linear combination vk_x\n                \n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\n                \n                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))\n                \n                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))\n                \n\n                // -A\n                mstore(_pPairing, calldataload(pA))\n                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))\n\n                // B\n                mstore(add(_pPairing, 64), calldataload(pB))\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\n\n                // alpha1\n                mstore(add(_pPairing, 192), alphax)\n                mstore(add(_pPairing, 224), alphay)\n\n                // beta2\n                mstore(add(_pPairing, 256), betax1)\n                mstore(add(_pPairing, 288), betax2)\n                mstore(add(_pPairing, 320), betay1)\n                mstore(add(_pPairing, 352), betay2)\n\n                // vk_x\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\n\n\n                // gamma2\n                mstore(add(_pPairing, 448), gammax1)\n                mstore(add(_pPairing, 480), gammax2)\n                mstore(add(_pPairing, 512), gammay1)\n                mstore(add(_pPairing, 544), gammay2)\n\n                // C\n                mstore(add(_pPairing, 576), calldataload(pC))\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\n\n                // delta2\n                mstore(add(_pPairing, 640), deltax1)\n                mstore(add(_pPairing, 672), deltax2)\n                mstore(add(_pPairing, 704), deltay1)\n                mstore(add(_pPairing, 736), deltay2)\n\n\n                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)\n\n                isOk := and(success, mload(_pPairing))\n            }\n\n            let pMem := mload(0x40)\n            mstore(0x40, add(pMem, pLastMem))\n\n            // Validate that all evaluations ∈ F\n            \n            checkField(calldataload(add(_pubSignals, 0)))\n            \n            checkField(calldataload(add(_pubSignals, 32)))\n            \n            checkField(calldataload(add(_pubSignals, 64)))\n            \n            checkField(calldataload(add(_pubSignals, 96)))\n            \n\n            // Validate all evaluations\n            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)\n\n            mstore(0, isValid)\n             return(0, 0x20)\n         }\n     }\n }\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}